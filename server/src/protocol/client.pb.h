// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef PROTOBUF_client_2eproto__INCLUDED
#define PROTOBUF_client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eproto();
void protobuf_AssignDesc_client_2eproto();
void protobuf_ShutdownFile_client_2eproto();

class LoginReq;
class EncryptKeyNtf;
class AuthReq;
class AuthAck;
class PingPong;

enum LoginReq_LoginType {
  LoginReq_LoginType_NewRole = 0,
  LoginReq_LoginType_OldRole = 1
};
bool LoginReq_LoginType_IsValid(int value);
const LoginReq_LoginType LoginReq_LoginType_LoginType_MIN = LoginReq_LoginType_NewRole;
const LoginReq_LoginType LoginReq_LoginType_LoginType_MAX = LoginReq_LoginType_OldRole;
const int LoginReq_LoginType_LoginType_ARRAYSIZE = LoginReq_LoginType_LoginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginReq_LoginType_descriptor();
inline const ::std::string& LoginReq_LoginType_Name(LoginReq_LoginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginReq_LoginType_descriptor(), value);
}
inline bool LoginReq_LoginType_Parse(
    const ::std::string& name, LoginReq_LoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginReq_LoginType>(
    LoginReq_LoginType_descriptor(), name, value);
}
enum ClientMsgId {
  eClientGateMsgIdMin = 1000,
  eLoginReq = 1001,
  eLoginAck = 1002,
  eEncryptKeyNtf = 1003,
  eAuthReq = 1004,
  eAuthAck = 1005,
  ePing = 1006,
  ePong = 1007,
  eSpeedTest = 1008,
  eLatencyTest = 1009,
  eClientGateMsgIdMax = 2000
};
bool ClientMsgId_IsValid(int value);
const ClientMsgId ClientMsgId_MIN = eClientGateMsgIdMin;
const ClientMsgId ClientMsgId_MAX = eClientGateMsgIdMax;
const int ClientMsgId_ARRAYSIZE = ClientMsgId_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMsgId_descriptor();
inline const ::std::string& ClientMsgId_Name(ClientMsgId value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMsgId_descriptor(), value);
}
inline bool ClientMsgId_Parse(
    const ::std::string& name, ClientMsgId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMsgId>(
    ClientMsgId_descriptor(), name, value);
}
enum ServerMsgId {
  ServerMsgId_EncryptKeyNotify = 1
};
bool ServerMsgId_IsValid(int value);
const ServerMsgId ServerMsgId_MIN = ServerMsgId_EncryptKeyNotify;
const ServerMsgId ServerMsgId_MAX = ServerMsgId_EncryptKeyNotify;
const int ServerMsgId_ARRAYSIZE = ServerMsgId_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerMsgId_descriptor();
inline const ::std::string& ServerMsgId_Name(ServerMsgId value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerMsgId_descriptor(), value);
}
inline bool ServerMsgId_Parse(
    const ::std::string& name, ServerMsgId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerMsgId>(
    ServerMsgId_descriptor(), name, value);
}
enum EncryptKeyDef {
  EncryptKeyLen = 32,
  EncryptHeadLen = 2,
  EncryptTailLen = 4,
  AuthKeyLen = 16,
  PublicKeyLen = 8,
  PrivateKeyLen = 20
};
bool EncryptKeyDef_IsValid(int value);
const EncryptKeyDef EncryptKeyDef_MIN = EncryptHeadLen;
const EncryptKeyDef EncryptKeyDef_MAX = EncryptKeyLen;
const int EncryptKeyDef_ARRAYSIZE = EncryptKeyDef_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncryptKeyDef_descriptor();
inline const ::std::string& EncryptKeyDef_Name(EncryptKeyDef value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncryptKeyDef_descriptor(), value);
}
inline bool EncryptKeyDef_Parse(
    const ::std::string& name, EncryptKeyDef* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptKeyDef>(
    EncryptKeyDef_descriptor(), name, value);
}
enum AuthResult {
  AUTH_OK = 0,
  AUTH_FAIL = 1
};
bool AuthResult_IsValid(int value);
const AuthResult AuthResult_MIN = AUTH_OK;
const AuthResult AuthResult_MAX = AUTH_FAIL;
const int AuthResult_ARRAYSIZE = AuthResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthResult_descriptor();
inline const ::std::string& AuthResult_Name(AuthResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthResult_descriptor(), value);
}
inline bool AuthResult_Parse(
    const ::std::string& name, AuthResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthResult>(
    AuthResult_descriptor(), name, value);
}
// ===================================================================

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginReq_LoginType LoginType;
  static const LoginType NewRole = LoginReq_LoginType_NewRole;
  static const LoginType OldRole = LoginReq_LoginType_OldRole;
  static inline bool LoginType_IsValid(int value) {
    return LoginReq_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    LoginReq_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    LoginReq_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    LoginReq_LoginType_LoginType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoginType_descriptor() {
    return LoginReq_LoginType_descriptor();
  }
  static inline const ::std::string& LoginType_Name(LoginType value) {
    return LoginReq_LoginType_Name(value);
  }
  static inline bool LoginType_Parse(const ::std::string& name,
      LoginType* value) {
    return LoginReq_LoginType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 clientVersion = 1;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 1;
  inline ::google::protobuf::int32 clientversion() const;
  inline void set_clientversion(::google::protobuf::int32 value);

  // required string deviceid = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // required string notifyid = 3;
  inline bool has_notifyid() const;
  inline void clear_notifyid();
  static const int kNotifyidFieldNumber = 3;
  inline const ::std::string& notifyid() const;
  inline void set_notifyid(const ::std::string& value);
  inline void set_notifyid(const char* value);
  inline void set_notifyid(const char* value, size_t size);
  inline ::std::string* mutable_notifyid();
  inline ::std::string* release_notifyid();
  inline void set_allocated_notifyid(::std::string* notifyid);

  // required string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int32 zoneid = 5;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 5;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);

  // required int32 userid = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 6;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 playerid = 7;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 7;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // required string job = 8;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 8;
  inline const ::std::string& job() const;
  inline void set_job(const ::std::string& value);
  inline void set_job(const char* value);
  inline void set_job(const char* value, size_t size);
  inline ::std::string* mutable_job();
  inline ::std::string* release_job();
  inline void set_allocated_job(::std::string* job);

  // required .LoginReq.LoginType loginType = 9;
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 9;
  inline ::LoginReq_LoginType logintype() const;
  inline void set_logintype(::LoginReq_LoginType value);

  // required int32 authType = 10;
  inline bool has_authtype() const;
  inline void clear_authtype();
  static const int kAuthTypeFieldNumber = 10;
  inline ::google::protobuf::int32 authtype() const;
  inline void set_authtype(::google::protobuf::int32 value);

  // required string authKey = 11;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 11;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_notifyid();
  inline void clear_has_notifyid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_authtype();
  inline void clear_has_authtype();
  inline void set_has_authkey();
  inline void clear_has_authkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;
  ::std::string* notifyid_;
  ::google::protobuf::int32 clientversion_;
  ::google::protobuf::int32 zoneid_;
  ::std::string* username_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 playerid_;
  ::std::string* job_;
  int logintype_;
  ::google::protobuf::int32 authtype_;
  ::std::string* authkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class EncryptKeyNtf : public ::google::protobuf::Message {
 public:
  EncryptKeyNtf();
  virtual ~EncryptKeyNtf();

  EncryptKeyNtf(const EncryptKeyNtf& from);

  inline EncryptKeyNtf& operator=(const EncryptKeyNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptKeyNtf& default_instance();

  void Swap(EncryptKeyNtf* other);

  // implements Message ----------------------------------------------

  EncryptKeyNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptKeyNtf& from);
  void MergeFrom(const EncryptKeyNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string publicKey = 1;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& publickey() const;
  inline void set_publickey(const ::std::string& value);
  inline void set_publickey(const char* value);
  inline void set_publickey(const char* value, size_t size);
  inline ::std::string* mutable_publickey();
  inline ::std::string* release_publickey();
  inline void set_allocated_publickey(::std::string* publickey);

  // required string privateKey = 2;
  inline bool has_privatekey() const;
  inline void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& privatekey() const;
  inline void set_privatekey(const ::std::string& value);
  inline void set_privatekey(const char* value);
  inline void set_privatekey(const char* value, size_t size);
  inline ::std::string* mutable_privatekey();
  inline ::std::string* release_privatekey();
  inline void set_allocated_privatekey(::std::string* privatekey);

  // required string authKey = 3;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 3;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // @@protoc_insertion_point(class_scope:EncryptKeyNtf)
 private:
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_privatekey();
  inline void clear_has_privatekey();
  inline void set_has_authkey();
  inline void clear_has_authkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickey_;
  ::std::string* privatekey_;
  ::std::string* authkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static EncryptKeyNtf* default_instance_;
};
// -------------------------------------------------------------------

class AuthReq : public ::google::protobuf::Message {
 public:
  AuthReq();
  virtual ~AuthReq();

  AuthReq(const AuthReq& from);

  inline AuthReq& operator=(const AuthReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthReq& default_instance();

  void Swap(AuthReq* other);

  // implements Message ----------------------------------------------

  AuthReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthReq& from);
  void MergeFrom(const AuthReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string authKey = 1;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 1;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // @@protoc_insertion_point(class_scope:AuthReq)
 private:
  inline void set_has_authkey();
  inline void clear_has_authkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* authkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static AuthReq* default_instance_;
};
// -------------------------------------------------------------------

class AuthAck : public ::google::protobuf::Message {
 public:
  AuthAck();
  virtual ~AuthAck();

  AuthAck(const AuthAck& from);

  inline AuthAck& operator=(const AuthAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAck& default_instance();

  void Swap(AuthAck* other);

  // implements Message ----------------------------------------------

  AuthAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthAck& from);
  void MergeFrom(const AuthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AuthResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::AuthResult result() const;
  inline void set_result(::AuthResult value);

  // required string encryptKey = 2;
  inline bool has_encryptkey() const;
  inline void clear_encryptkey();
  static const int kEncryptKeyFieldNumber = 2;
  inline const ::std::string& encryptkey() const;
  inline void set_encryptkey(const ::std::string& value);
  inline void set_encryptkey(const char* value);
  inline void set_encryptkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptkey();
  inline ::std::string* release_encryptkey();
  inline void set_allocated_encryptkey(::std::string* encryptkey);

  // @@protoc_insertion_point(class_scope:AuthAck)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_encryptkey();
  inline void clear_has_encryptkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encryptkey_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static AuthAck* default_instance_;
};
// -------------------------------------------------------------------

class PingPong : public ::google::protobuf::Message {
 public:
  PingPong();
  virtual ~PingPong();

  PingPong(const PingPong& from);

  inline PingPong& operator=(const PingPong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingPong& default_instance();

  void Swap(PingPong* other);

  // implements Message ----------------------------------------------

  PingPong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingPong& from);
  void MergeFrom(const PingPong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pingpong = 1;
  inline bool has_pingpong() const;
  inline void clear_pingpong();
  static const int kPingpongFieldNumber = 1;
  inline const ::std::string& pingpong() const;
  inline void set_pingpong(const ::std::string& value);
  inline void set_pingpong(const char* value);
  inline void set_pingpong(const char* value, size_t size);
  inline ::std::string* mutable_pingpong();
  inline ::std::string* release_pingpong();
  inline void set_allocated_pingpong(::std::string* pingpong);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PingPong)
 private:
  inline void set_has_pingpong();
  inline void clear_has_pingpong();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pingpong_;
  ::google::protobuf::uint64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static PingPong* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginReq

// required int32 clientVersion = 1;
inline bool LoginReq::has_clientversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_clientversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_clientversion() {
  clientversion_ = 0;
  clear_has_clientversion();
}
inline ::google::protobuf::int32 LoginReq::clientversion() const {
  return clientversion_;
}
inline void LoginReq::set_clientversion(::google::protobuf::int32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// required string deviceid = 2;
inline bool LoginReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginReq::deviceid() const {
  return *deviceid_;
}
inline void LoginReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LoginReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string notifyid = 3;
inline bool LoginReq::has_notifyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_notifyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_notifyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_notifyid() {
  if (notifyid_ != &::google::protobuf::internal::kEmptyString) {
    notifyid_->clear();
  }
  clear_has_notifyid();
}
inline const ::std::string& LoginReq::notifyid() const {
  return *notifyid_;
}
inline void LoginReq::set_notifyid(const ::std::string& value) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(value);
}
inline void LoginReq::set_notifyid(const char* value) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(value);
}
inline void LoginReq::set_notifyid(const char* value, size_t size) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_notifyid() {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  return notifyid_;
}
inline ::std::string* LoginReq::release_notifyid() {
  clear_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notifyid_;
    notifyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_notifyid(::std::string* notifyid) {
  if (notifyid_ != &::google::protobuf::internal::kEmptyString) {
    delete notifyid_;
  }
  if (notifyid) {
    set_has_notifyid();
    notifyid_ = notifyid;
  } else {
    clear_has_notifyid();
    notifyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 4;
inline bool LoginReq::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginReq::username() const {
  return *username_;
}
inline void LoginReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 zoneid = 5;
inline bool LoginReq::has_zoneid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_zoneid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 LoginReq::zoneid() const {
  return zoneid_;
}
inline void LoginReq::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// required int32 userid = 6;
inline bool LoginReq::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 LoginReq::userid() const {
  return userid_;
}
inline void LoginReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// required int32 playerid = 7;
inline bool LoginReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 LoginReq::playerid() const {
  return playerid_;
}
inline void LoginReq::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string job = 8;
inline bool LoginReq::has_job() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_job() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_job() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_job() {
  if (job_ != &::google::protobuf::internal::kEmptyString) {
    job_->clear();
  }
  clear_has_job();
}
inline const ::std::string& LoginReq::job() const {
  return *job_;
}
inline void LoginReq::set_job(const ::std::string& value) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(value);
}
inline void LoginReq::set_job(const char* value) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(value);
}
inline void LoginReq::set_job(const char* value, size_t size) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_job() {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  return job_;
}
inline ::std::string* LoginReq::release_job() {
  clear_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_;
    job_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_job(::std::string* job) {
  if (job_ != &::google::protobuf::internal::kEmptyString) {
    delete job_;
  }
  if (job) {
    set_has_job();
    job_ = job;
  } else {
    clear_has_job();
    job_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .LoginReq.LoginType loginType = 9;
inline bool LoginReq::has_logintype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_logintype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::LoginReq_LoginType LoginReq::logintype() const {
  return static_cast< ::LoginReq_LoginType >(logintype_);
}
inline void LoginReq::set_logintype(::LoginReq_LoginType value) {
  assert(::LoginReq_LoginType_IsValid(value));
  set_has_logintype();
  logintype_ = value;
}

// required int32 authType = 10;
inline bool LoginReq::has_authtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_authtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_authtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_authtype() {
  authtype_ = 0;
  clear_has_authtype();
}
inline ::google::protobuf::int32 LoginReq::authtype() const {
  return authtype_;
}
inline void LoginReq::set_authtype(::google::protobuf::int32 value) {
  set_has_authtype();
  authtype_ = value;
}

// required string authKey = 11;
inline bool LoginReq::has_authkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginReq::set_has_authkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginReq::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginReq::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& LoginReq::authkey() const {
  return *authkey_;
}
inline void LoginReq::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void LoginReq::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void LoginReq::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  return authkey_;
}
inline ::std::string* LoginReq::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EncryptKeyNtf

// required string publicKey = 1;
inline bool EncryptKeyNtf::has_publickey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptKeyNtf::set_has_publickey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptKeyNtf::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptKeyNtf::clear_publickey() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    publickey_->clear();
  }
  clear_has_publickey();
}
inline const ::std::string& EncryptKeyNtf::publickey() const {
  return *publickey_;
}
inline void EncryptKeyNtf::set_publickey(const ::std::string& value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void EncryptKeyNtf::set_publickey(const char* value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void EncryptKeyNtf::set_publickey(const char* value, size_t size) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptKeyNtf::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  return publickey_;
}
inline ::std::string* EncryptKeyNtf::release_publickey() {
  clear_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickey_;
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptKeyNtf::set_allocated_publickey(::std::string* publickey) {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (publickey) {
    set_has_publickey();
    publickey_ = publickey;
  } else {
    clear_has_publickey();
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string privateKey = 2;
inline bool EncryptKeyNtf::has_privatekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptKeyNtf::set_has_privatekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptKeyNtf::clear_has_privatekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptKeyNtf::clear_privatekey() {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    privatekey_->clear();
  }
  clear_has_privatekey();
}
inline const ::std::string& EncryptKeyNtf::privatekey() const {
  return *privatekey_;
}
inline void EncryptKeyNtf::set_privatekey(const ::std::string& value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void EncryptKeyNtf::set_privatekey(const char* value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void EncryptKeyNtf::set_privatekey(const char* value, size_t size) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptKeyNtf::mutable_privatekey() {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  return privatekey_;
}
inline ::std::string* EncryptKeyNtf::release_privatekey() {
  clear_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = privatekey_;
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptKeyNtf::set_allocated_privatekey(::std::string* privatekey) {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (privatekey) {
    set_has_privatekey();
    privatekey_ = privatekey;
  } else {
    clear_has_privatekey();
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string authKey = 3;
inline bool EncryptKeyNtf::has_authkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptKeyNtf::set_has_authkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptKeyNtf::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptKeyNtf::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& EncryptKeyNtf::authkey() const {
  return *authkey_;
}
inline void EncryptKeyNtf::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void EncryptKeyNtf::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void EncryptKeyNtf::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptKeyNtf::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  return authkey_;
}
inline ::std::string* EncryptKeyNtf::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptKeyNtf::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthReq

// required string authKey = 1;
inline bool AuthReq::has_authkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthReq::set_has_authkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthReq::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthReq::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& AuthReq::authkey() const {
  return *authkey_;
}
inline void AuthReq::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void AuthReq::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void AuthReq::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthReq::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  return authkey_;
}
inline ::std::string* AuthReq::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthReq::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthAck

// required .AuthResult result = 1;
inline bool AuthAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::AuthResult AuthAck::result() const {
  return static_cast< ::AuthResult >(result_);
}
inline void AuthAck::set_result(::AuthResult value) {
  assert(::AuthResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// required string encryptKey = 2;
inline bool AuthAck::has_encryptkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthAck::set_has_encryptkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthAck::clear_has_encryptkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthAck::clear_encryptkey() {
  if (encryptkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptkey_->clear();
  }
  clear_has_encryptkey();
}
inline const ::std::string& AuthAck::encryptkey() const {
  return *encryptkey_;
}
inline void AuthAck::set_encryptkey(const ::std::string& value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
}
inline void AuthAck::set_encryptkey(const char* value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
}
inline void AuthAck::set_encryptkey(const char* value, size_t size) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthAck::mutable_encryptkey() {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  return encryptkey_;
}
inline ::std::string* AuthAck::release_encryptkey() {
  clear_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptkey_;
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthAck::set_allocated_encryptkey(::std::string* encryptkey) {
  if (encryptkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptkey_;
  }
  if (encryptkey) {
    set_has_encryptkey();
    encryptkey_ = encryptkey;
  } else {
    clear_has_encryptkey();
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PingPong

// required string pingpong = 1;
inline bool PingPong::has_pingpong() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingPong::set_has_pingpong() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingPong::clear_has_pingpong() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingPong::clear_pingpong() {
  if (pingpong_ != &::google::protobuf::internal::kEmptyString) {
    pingpong_->clear();
  }
  clear_has_pingpong();
}
inline const ::std::string& PingPong::pingpong() const {
  return *pingpong_;
}
inline void PingPong::set_pingpong(const ::std::string& value) {
  set_has_pingpong();
  if (pingpong_ == &::google::protobuf::internal::kEmptyString) {
    pingpong_ = new ::std::string;
  }
  pingpong_->assign(value);
}
inline void PingPong::set_pingpong(const char* value) {
  set_has_pingpong();
  if (pingpong_ == &::google::protobuf::internal::kEmptyString) {
    pingpong_ = new ::std::string;
  }
  pingpong_->assign(value);
}
inline void PingPong::set_pingpong(const char* value, size_t size) {
  set_has_pingpong();
  if (pingpong_ == &::google::protobuf::internal::kEmptyString) {
    pingpong_ = new ::std::string;
  }
  pingpong_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingPong::mutable_pingpong() {
  set_has_pingpong();
  if (pingpong_ == &::google::protobuf::internal::kEmptyString) {
    pingpong_ = new ::std::string;
  }
  return pingpong_;
}
inline ::std::string* PingPong::release_pingpong() {
  clear_has_pingpong();
  if (pingpong_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pingpong_;
    pingpong_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PingPong::set_allocated_pingpong(::std::string* pingpong) {
  if (pingpong_ != &::google::protobuf::internal::kEmptyString) {
    delete pingpong_;
  }
  if (pingpong) {
    set_has_pingpong();
    pingpong_ = pingpong;
  } else {
    clear_has_pingpong();
    pingpong_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time = 2;
inline bool PingPong::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingPong::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingPong::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingPong::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 PingPong::time() const {
  return time_;
}
inline void PingPong::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginReq_LoginType>() {
  return ::LoginReq_LoginType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClientMsgId>() {
  return ::ClientMsgId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerMsgId>() {
  return ::ServerMsgId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EncryptKeyDef>() {
  return ::EncryptKeyDef_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AuthResult>() {
  return ::AuthResult_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eproto__INCLUDED
